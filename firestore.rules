/**
 * firestore.rules
 * 
 * Purpose: Firestore security rules for Time 2 Trade collections.
 * Key responsibility and main functionality: Protect user data, enforce read/write access,
 * and restrict server-managed collections.
 * 
 * Changelog:
 * v1.15.0 - 2026-02-11 - BEP CRITICAL FIX: Added missing isAdmin() and isSuperAdmin() helper
 *                       functions. The systemActivityLog read rule referenced these undefined
 *                       functions, causing "Missing or insufficient permissions" errors for ALL
 *                       users (even non-auth trying to read public visibility logs). Errors now
 *                       propagate correctly from insightsQueryService to InsightsPanel UI.
 *                       Non-auth users can now see public insights in Blog/Calendar.
 * v1.14.0 - 2026-02-10 - BEP: Allow unauthenticated reads of public visibility systemActivityLog
 *                       entries. Non-auth users can now see trending insights in InsightsPanel.
 *                       Internal/admin visibility still requires auth + role.
 * v1.13.0 - 2026-02-07 - BEP ENGAGEMENT PERMISSIONS FIX: Split viewCount and likeCount permissions.
 *                       (1) viewCount: ANY user (auth + guest) can increment on published posts.
 *                       (2) likeCount: ONLY authenticated users can update. Root cause: v1.12.0 rule
 *                       required isAuthenticated() for both fields, blocking guests from incrementing
 *                       view counts. Now guests can track page views while likes remain auth-only.
 * v1.12.0 - 2026-02-07 - BEP: Add blogActivity subcollection rules (readHistory, likes). Allow auth users to update engagement fields (viewCount, likeCount) on blogPosts.
 * v1.12.0 - 2026-02-09 - Phase 7: Add visibility field enforcement to systemActivityLog read rules
 * v1.11.0 - 2026-02-05 - BEP: Allow all authenticated users to read systemActivityLog (client-side filtering per role)
 * v1.9.0 - 2026-02-05 - Allow authenticated users to create activity logs (frontend logging). Superadmin write/update/delete.
 * v1.8.0 - 2026-02-05 - Add rules for systemActivityLog collection (admin activity audit trail).
 * v1.7.0 - 2026-02-05 - BEP: Allow public read on blogSlugIndex for unauthenticated users (needed for slug → postId lookup)
 * v1.6.0 - 2026-02-06 - BEP: Fix isPublishedPost() to allow true public read for unauthenticated users
 * v1.5.0 - 2026-02-04 - Add rules for blogAuthors and blogAuthorSlugIndex (Phase 5.B Blog Taxonomy)
 * v1.4.0 - 2026-02-04 - Add rules for blogPosts and blogSlugIndex collections (Phase 1 Blog)
 * v1.3.0 - 2026-02-03 - Add rules for preferences subcollection (quiet hours).
 * v1.2.0 - 2026-01-23 - Add rules for deviceTokens and notificationStats for FCM.
 * v1.1.0 - 2026-01-23 - Add rules for unified reminders and notification triggers.
 * v1.0.0 - 2025-09-15 - Initial security rules.
 */

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if user has blog CMS role (author, admin, superadmin)
    function hasBlogCmsRole() {
      return isAuthenticated() && (
        request.auth.token.role == 'author' ||
        request.auth.token.role == 'admin' ||
        request.auth.token.role == 'superadmin' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['author', 'admin', 'superadmin']
      );
    }

    // Helper function to check if user has admin role
    function isAdmin() {
      return isAuthenticated() && (
        request.auth.token.role == 'admin' ||
        request.auth.token.role == 'superadmin' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'superadmin']
      );
    }

    // Helper function to check if user has superadmin role
    function isSuperAdmin() {
      return isAuthenticated() && (
        request.auth.token.role == 'superadmin' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin'
      );
    }

    // Helper function to check if blog post is published (works for unauthenticated users)
    function isPublishedPost() {
      return resource != null && resource.data.status == 'published';
    }

    // Users collection - authenticated users can read/write their own data
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId);

      // Favorites subcollection - allow owners to manage their own favorites
      match /favorites/{favoriteId} {
        allow read, write: if isOwner(userId);
      }

      // Event Notes subcollection - owners can manage notes and metadata
      match /eventNotes/{eventId} {
        allow read, write: if isOwner(userId);

        // Notes nested subcollection
        match /notes/{noteId} {
          allow read, write: if isOwner(userId);
        }
      }

      // Custom Events subcollection - owners manage their own reminders
      match /customEvents/{eventId} {
        allow read, write: if isOwner(userId);
      }

      // Unified Reminders subcollection - owners manage their reminders
      match /reminders/{reminderId} {
        allow read, write: if isOwner(userId);
      }

      // Notification Triggers subcollection - write-only by client (read reserved for future server flows)
      match /notificationTriggers/{triggerId} {
        allow read: if false;
        allow write: if isOwner(userId);
      }

      // Device tokens for FCM push notifications
      match /deviceTokens/{tokenId} {
        allow read, write: if isOwner(userId);
      }

      // Notification stats (daily caps)
      match /notificationStats/{statsId} {
        allow read, write: if isOwner(userId);
      }

      // Notifications subcollection - owners access their own notification history
      match /notifications/{notificationId} {
        allow read, write: if isOwner(userId);
      }

      // Preferences subcollection - owners manage their notification/app preferences
      match /preferences/{prefId} {
        allow read, write: if isOwner(userId);
      }

      // Blog Activity subcollection - read tracking and likes (v1.12.0)
      // Structure: users/{uid}/blogActivity/readHistory  → { postIds: [...] }
      //            users/{uid}/blogActivity/likes        → { postIds: [...] }
      match /blogActivity/{docId} {
        allow read, write: if isOwner(userId);
      }
    }

    // Economic Events Calendar - public read access for all events
    // Only Cloud Functions can write (via service account)
    match /economicEventsCalendar/{eventId} {
      allow read: if true; // Public read access
      allow write: if false; // Only Cloud Functions can write
    }

    // Economic Events - Multi-source subcollections (v2.2.0+)
    // Structure: /economicEvents/{source}/events/{eventId}
    // Public read access for all sources, only Cloud Functions can write
    match /economicEvents/{source}/events/{eventId} {
      allow read: if true; // Public read access
      allow write: if false; // Only Cloud Functions can write
    }

    // Canonical Economic Events - provider-agnostic documents (v3.0.0+)
    // Structure: /economicEvents/events/events/{eventId}
    // Public read for all users, superadmin write for manual editing
    match /economicEvents/events/events/{eventId} {
      allow read: if true; // Public read access for all events
      // Check superadmin via custom claim OR Firestore user document
      allow write: if request.auth != null && (
        request.auth.token.role == 'superadmin' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin'
      );
    }

    // Economic Event Descriptions - public read access
    // Only Cloud Functions or privileged admins can write
    match /economicEventDescriptions/{docId} {
      allow read: if true; // Public read access
      allow write: if
        // Service accounts (Cloud Functions) always allowed
        request.auth.token.firebase.sign_in_provider == 'firebase' && request.auth.token.admin == true
        ||
        // Allow privileged human users with custom claims (role or superadmin flag)
        request.auth != null && (
          request.auth.token.role == 'superadmin' ||
          request.auth.token.superadmin == true
        )
        ||
        // TEMPORARY: Allow any authenticated user (for manual uploads)
        // TODO: Remove this after setting up proper admin accounts
        isAuthenticated();
    }

    // System Jobs - public read access (used for cache validation)
    // Only Cloud Functions can write
    match /systemJobs/{jobId} {
      allow read: if true; // Public read access for cache validation
      allow write: if false; // Only Cloud Functions can write
    }

    // Contact Messages - allow submissions from visitors and authenticated users, restrict reads to admins
    match /contactMessages/{docId} {
      allow create: if
        request.resource.data.email is string &&
        request.resource.data.message is string &&
        request.resource.data.phoneE164 is string &&
        request.resource.data.phoneCountry is string &&
        request.resource.data.phoneCallingCode is string &&
        request.resource.data.status is string &&
        request.resource.data.source is string &&
        request.resource.data.isAuthenticated is bool &&
        request.resource.data.createdAt is timestamp &&
        (
          !('authEmail' in request.resource.data) ||
          request.resource.data.authEmail is string ||
          request.resource.data.authEmail == null
        );

      // Limit reads to admins with custom claim
      allow read: if request.auth != null && (request.auth.token.role == 'admin' || request.auth.token.role == 'superadmin' || request.auth.token.superadmin == true);
      allow update, delete: if false;
    }

    // ==================== BLOG COLLECTIONS (v1.4.0+) ====================
    
    // Blog Posts - Multi-language blog content
    // Structure: /blogPosts/{postId}
    // Public read for published posts only, CMS roles can read all + write
    match /blogPosts/{postId} {
      // Public can read published posts only
      // CMS roles can read all posts (including drafts)
      // For aggregation queries (blog stats), check auth token first, then fallback to user doc
      allow read: if isPublishedPost() || (
        isAuthenticated() && (
          request.auth.token.role in ['author', 'admin', 'superadmin'] ||
          (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && 
           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['author', 'admin', 'superadmin'])
        )
      );
      
      // Only CMS roles can create/update/delete
      allow create: if hasBlogCmsRole() &&
        // Validate required fields on create
        request.resource.data.status in ['draft', 'published', 'unpublished'] &&
        request.resource.data.createdAt is timestamp &&
        request.resource.data.updatedAt is timestamp &&
        request.resource.data.author.uid is string &&
        request.resource.data.author.displayName is string &&
        request.resource.data.category is string;
      
      allow update: if hasBlogCmsRole() &&
        // Validate status transitions
        request.resource.data.status in ['draft', 'published', 'unpublished'] &&
        request.resource.data.updatedAt is timestamp;

      // Engagement updates (viewCount, likeCount)
      // View count: ANY user (auth + guest) can increment on published posts
      // Like count: ONLY authenticated users can update (via separate like system)
      // BEP: Guests increment viewCount to track all page visits, not just authenticated users
      allow update: if isPublishedPost() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount']) ||
      (isAuthenticated() &&
        isPublishedPost() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likeCount']));
      
      allow delete: if hasBlogCmsRole();
    }

    // Blog Slug Index - Uniqueness enforcement for slugs per language
    // Structure: /blogSlugIndex/{lang_slug} → { postId: string }
    // Example: /blogSlugIndex/en_trading-tips-2024 → { postId: "abc123" }
    match /blogSlugIndex/{slugKey} {
      // Public read needed for slug → postId lookup (getBlogPostBySlug)
      // Actual post access is controlled by blogPosts rules
      allow read: if true;
      
      // Create only if postId is provided
      allow create: if hasBlogCmsRole() &&
        request.resource.data.postId is string;
      
      // Update only if same postId (re-claim same slug)
      allow update: if hasBlogCmsRole() &&
        request.resource.data.postId is string;
      
      // Delete allowed for CMS roles (when post is deleted or slug changed)
      allow delete: if hasBlogCmsRole();
    }

    // Blog Renders - Manifest of rendered HTML files per post (for cleanup)
    // Structure: /blogRenders/{postId} → { paths: string[], renderedAt: timestamp }
    // Only Cloud Functions can write (generates HTML), CMS roles can read for debug
    match /blogRenders/{postId} {
      allow read: if hasBlogCmsRole();
      allow write: if false; // Only Cloud Functions can write
    }

    // Blog Authors - Author profiles for attribution and author pages (Phase 5.B)
    // Structure: /blogAuthors/{authorId}
    // Public read for author info, CMS roles can manage
    match /blogAuthors/{authorId} {
      // Public can read author profiles (shown on posts and author pages)
      allow read: if true;
      
      // Only CMS roles can create/update/delete authors
      allow create: if hasBlogCmsRole() &&
        request.resource.data.slug is string &&
        request.resource.data.displayName is string &&
        request.resource.data.createdAt is timestamp;
      
      allow update: if hasBlogCmsRole() &&
        request.resource.data.updatedAt is timestamp;
      
      allow delete: if hasBlogCmsRole();
    }

    // Blog Author Slug Index - Uniqueness enforcement for author slugs (Phase 5.B)
    // Structure: /blogAuthorSlugIndex/{slug} → { authorId: string }
    match /blogAuthorSlugIndex/{slug} {
      // CMS roles can read/write slug index
      allow read: if hasBlogCmsRole();
      
      allow create: if hasBlogCmsRole() &&
        request.resource.data.authorId is string;
      
      allow update: if hasBlogCmsRole() &&
        request.resource.data.authorId is string;
      
      allow delete: if hasBlogCmsRole();
    }

    // System Activity Log - Admin audit trail for events, syncs, etc.
    // Structure: /systemActivityLog/{activityId} → { type, title, description, severity, visibility, createdAt, metadata, source }
    // Visibility: 'public' (all users), 'internal' (admin+), 'admin' (superadmin only)
    // Backend (Cloud Functions) and Frontend (authenticated users) can write
    match /systemActivityLog/{activityId} {
      // Read: Enforce visibility-based access control
      // - 'public': ALL users (including unauthenticated) — trending insights
      // - 'internal': admin + superadmin (requires auth)
      // - 'admin': superadmin only (requires auth)
      allow read: if
        resource.data.visibility == 'public' ||
        (isAuthenticated() && resource.data.visibility == 'internal' && isAdmin()) ||
        (isAuthenticated() && resource.data.visibility == 'admin' && isSuperAdmin());

      // Authenticated users can create (frontend logging)
      allow create: if isAuthenticated() &&
        request.resource.data.keys().hasAll(['type', 'title', 'description', 'createdAt', 'visibility']) &&
        request.resource.data.type is string &&
        request.resource.data.title is string &&
        request.resource.data.description is string &&
        request.resource.data.visibility in ['public', 'internal', 'admin'] &&
        (request.resource.data.severity == null || request.resource.data.severity is string) &&
        (request.resource.data.source == null || request.resource.data.source is string);

      // Only superadmin can update/delete activity logs
      allow update, delete: if isAuthenticated() && (
        request.auth.token.role == 'superadmin' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin'
      );
    }

    // Deny all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}